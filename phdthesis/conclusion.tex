\chapter{Conclusion}
\label{ch:conclusion}

The conclusion chapter will summarize the contributions of the work, and also preview some directions for future research.  One question reserved for future work is how to generate nice induction rules for indirect-recursive datatypes, like the \texttt{Tree} type mentioned earlier.  In some cases it is possible to treat indirect recursion like mutual recursion, which suggests a particular form of induction rule; however, other formulations of induction rules are also possible.  Exploring this area is beyond the scope of my thesis.

Other directions for future work involve adding support for pattern matching and recursive let-bindings to HOLCF.  I have done some initial work on how to \emph{express} such concepts in HOLCF, so users can write case- and let-expressions having the correct meaning, using nice syntax.  However, finding the best way to interactively \emph{reason} with such expressions is a much deeper problem.

This section will also have a survey of related work.  This will include other formalizations of domain theory, other implementations of definition packages for theorem provers, and alternative approaches (besides domain theory) to formalizing functional languages.

In conclusion, we can see that the definition packages and automation provided by \HOLCF{11} satisfy all of the claims from the thesis statement in Chapter~\ref{ch:intro}. 

First, \HOLCF{11} can handle a large class of functional programs, including many programs that cannot be formalized in any other proof tool. With the \textsc{Fixrec} package, users can define arbitrary recursive functions with pattern matching, without having to use explicit fixed point combinators (as was the case in \HOLCF{99}) and without having to prove termination. The new \textsc{Domain} package also brings a lot more programs into the scope of HOLCF. In particular, the ability to define and reason about indirect-recursive datatypes opens up HOLCF to an important new class of programs, including many interesting Haskell monads. The library of powerdomains is another original feature of \HOLCF{11}, which expands HOLCF's range to include nondeterministic and concurrent programs.

Second, \HOLCF{11} provides a high level of automation, making it possible to write very short proof scripts that can quickly solve even non-trivial theorems. The simplification rules for continuity and admissibility described in Chapter~\ref{ch:holcf} play an important role, because those properties are involved in the most common reasoning principles for HOLCF (beta-reduction and induction proofs, respectively). The extensive collection of simplification rules generated by the \textsc{Domain} package also has a real impact on user proofs, helping to quickly discharge many trivial subgoals. The case studies presented earlier in this chapter demonstrate how well this automation works in practice: Many proofs scripts can be reduced all the way down to a basic induct-and-simplify pattern.

Finally, it is important to point out once again that all of the packages implemented in \HOLCF{11} are completely definitional. No new axioms are required---now HOLCF is really a conservative extension of Isabelle/HOL. Each of the definitional packages uses the formalization of mathematics from domain theory: \textsc{Fixrec} uses the theory of least fixed points; the \textsc{Domain} package uses least fixed points as well, but also a lot more, including the category of bifinite domains, universal domains, and the deflation model for solving domain equations. This work can be interpreted as a success story for domain theory: The primary impetus behind developing domain theory is to create a theory for reasoning about computation. By using domain theory to implement a definitional HOLCF, and to build tools for reasoning about recursive functions and datatypes, this motivation for developing domain theory in the first place is finally fulfilled.


\section{Evaluation of thesis claims}

\HOLCF{11} claims to have an unprecedented combination of expressiveness, automation, and confidence. To substantiate this claim, we evaluate several other reasoning tools along these dimensions.

Related work:

- Compare datatype definition mechanisms in various provers
-- Isabelle/HOL
-- Coq (also codatatypes)
-- PVS datatypes (codatatypes?)  (not LCF-style implementation)
-- ACL2 is untyped (no datatype definition or inifinite objects)
-- Isabelle/ZF datatypes as inductive sets (codatatypes as coinductives)
-- HOL Light (highest confidence, simplest kernel)
-- Agda (compare to typechecking; less automation)

Other formalizations of domain theory:
- Domain theory in Coq
- Agerholm HOL-CPO
- \HOLCF{95}/99
- Domain theory in PVS?

PVS: good integration of rewriting with decision procedures
PVS has limitations w.r.t. polymorphism (basically equivalent to Isabelle locales: can have fixed arbitrary types, but no polymorphic definitions)

Other theorem provers:

Rewriting proofs:
- Maude (inductive theorem proving?)

\begin{itemize}

\item HERA (Andy Gill) \cite{Gill06HERA}

\item \textsc{Sparkle} (for \textsc{Clean}) \cite{Mol01}. It is easy to express Clean programs in \textsc{Sparkle}, because \textsc{Sparkle} is designed to do reasoning directly on the Clean language. (Contrast to HOLCF, which is intended to be able to express a common subset of various functional languages, but requires a bit of translation e.g.\ from Haskell.) However, \textsc{Sparkle} does not support the entire Clean language, so sometimes users must simplify their programs before they can reason about them.

Properties in \textsc{Sparkle} are expressed in a logic that includes equality, various logical connectives, and universal and existential quantification. User-defined predicates are limited to executable functions that produce booleans. (Less expressive property language than \HOLCF{11}, approximately equal to Cambridge LCF.) \textsc{Sparkle} does model bottoms, partial values, and strictness annotations. (They say ``Strictness annotations are not supported by any existing theorem prover.'' They obviously didn't know about HOLCF!)

Automation in \textsc{Sparkle}: \textsc{Sparkle} has a collection of built-in proof tactics, including rewriting, induction over datatypes, case analysis, and more. It also has a hint mechanism that can select and apply tactics automatically, so proofs of some simple theorems can completed without user interaction. (Not as customizable as Isabelle.) (Weak reasoning principles: In \textsc{Sparkle}, induction over mutually recursive or indirect-recursive types gives no inductive hypothesis.)

Confidence of \textsc{Sparkle}: \textsc{Sparkle} is implemented in the \textsc{Clean} language. However, it does not adhere to the LCF architecture---to trust in the correctness of a proof, it is necessary to trust the code implementing each tactic used in the proof. (Many 

%Unfortunately, at least one \textsc{Sparkle} tactic is unsound: The induction tactic does not check for admissibility, so nothing prevents users from proving invalid theorems like \hs{$\forall$xs. $\exists$n. take n xs = xs} by induction on the lazy list variable \hs{xs}. (EDIT: it looks like the default list type in Clean is actually strict; induction on lazy datatypes actually does perform an admissibility check.)

\item Extended Static Checking for Haskell \cite{Xu06}. What it is: ESC/Haskell is a static analysis tool for Haskell programs, which aims to prove the absence of certain run-time errors. The tool relies on annotations of the Haskell code with pre- and post-conditions, which are themselves coded as Haskell expressions. The ESC/Haskell is... Expressiveness: ESC/Haskell

\end{itemize}

Type checking (absence of certain run-time faults)
\cite{Milner78} Milner's type system (the same used for ML and other functional languages). A program is said to ``go wrong'' if it ever tries to evaluate an application \hs{f x} where \hs{f} is not a function, or if it tries to do a case analysis on \hs{y} where \hs{y} is not a valid data constructor. Milner proved that ``well-typed programs never go wrong.'' Milner's type system is completely automatic: Most-general types can be determined by a type inference algorithm.

Fancier type systems can prove stronger properties, at the expense of some automation. First, polymorphic types: Checking that a Haskell program has a polymorphic type proves more than just the absence of run-time errors: It also establishes some non-trivial ``free theorems'' \cite{Wadler89Free}, based on a property of Haskell called \emph{parametricity}. Essentially, parametricity means that polymorphic functions must treat their arguments in an abstract way that is uniform for all type instances. For example, a list-transforming function with the polymorphic type \hs{$\forall$a. [a] -> [a]} can reorder or repeat the elements of the list, but it is not able to analyze any of the elements. Haskell's parametricity implies that the type \hs{$\forall$a. a -> a} is very limited: A function of this type, if it terminates, must simply return its argument unchanged.

Rank-2 polymorphism: foldr/build fusion \cite{ShortCut93} \hs{build g = g (:) []} It has a rank-2 polymorphic type \hs{build :: $\forall$a. ($\forall$b. (a -> b -> b) -> b -> b) -> [a]}. The free theorem for this type justifies the foldr/build fusion rule: \hs{foldr k z (build g) = g k z}.

-- runST / parametricity properties

- Catch: Checking for pattern completeness (absence of pattern match failure) \cite{Mitchell2008}. This is a completely automatic tool that takes a Haskell program as input, and attempts to prove the absence of run-time pattern match failure. Very high automation (no user interaction at all), but limited expressiveness: No properties other than absence of pattern match failure can be proven.


------------

Big lessons: Importance of choosing the right (small) set of domain-theoretic concepts to formalize. 


Note that the design of HOLCF was deeply influenced by the set of features available in Isabelle.
Features of Isabelle that were important for HOLCF:
- type inference with polymorphism
- type classes
- programmable tactics
- extensible simplifier

Limitations that Isabelle imposes on HOLCF
- no first-class polymorphism (existential types, nested datatypes, polymorphic recursion don't work)
- no reflection (can't prove in Isabelle that the packages are implemented correctly)

